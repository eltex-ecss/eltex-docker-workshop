<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Docker</title>

  <meta name="description" content="Docker workshop slides">
  <meta name="author" content="Artem Kolin">
  <meta name="author" content="Loic Delestra">

  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <!-- <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /> -->

  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"> -->

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/beige.css" id="theme">

  <link rel="stylesheet" href="css/custom.css">


  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">
    <section data-markdown>
      <script type="text/template">
        # Docker
      </script>
    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ### Слайды здесь:
          <img src="img/qr-sc.png" alt="">
        </script>
      </section>
    </section>

    <!--#1. Введение-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #1. Введение
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Что это ?
          Docker - это платформа для разработки, поставки и запуска приложений с использованием технологии
          контейнерной виртуализации.
          <br>
          <br>
          Платформа Docker содержит ряд различных утилит.
          <br>
          <br>
          >Docker
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Что это ?
          Docker - это программное обеспечение для автоматизации развёртывания и управления приложениями в средах с
          поддержкой контейнеризации. Позволяет «упаковать» приложение со всем его окружением и зависимостями в
          контейнер, который может быть перенесён на любую Linux-систему
          <br>
          <br>
          >Wikipedia
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          #История
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Одно приложение на одном физическом сервере
          <img src="img/docker_one_app_one_server.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Недостатки
          - Длительное время развертывания
          - Огромная цена
          - Простой ресурсов
          - Сложности масштабирования и миграции
          - Vendor Lock
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Hypervisor
          - Один физический сервер может содержать несколько независимых приложений
          - Каждое приложение изолировано внутри своей VM

          <img src="img/docker_hypervisor_based_virtualization.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Преимущества
          - Лучшее распределение ресурсов
          - Один физический сервер разделен на ряд VM
          - Легче масштабировать
          - Легко перенести
          - Можно запустить в облаке
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Ограничения
          - Для каждой VM по прежнему требуется
            - выделение CPU
            - хранилище
            - RAM
            - установка гостевой ОС
          - Чем больше VM запускаешь, тем больше нужно ресурсов
          - Гостевая OС впустую потребляет ресурсы
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Контейнеры
          >Контейнерная виртуализация использует ядро основной ОС для запуска множества экземпляров гостевых ОС

          - Каждый экземпляр гостевой ОС называется контейнер
          - Каждый контейнер имеет собственные
            - корневую файловую систему
            - процессы
            - память
            - сетевые порты
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Контейнеры
          <img src="img/docker_containers_oskernel.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Преимущества контейнеров перед VM
          - Легковесны
          - Не требуют установки гостевой ОС
          - Меньшее потребление CPU, RAM, хранилища
          - Можно запустить большее количество контейнеров на одной машине
          - Бо́льшая портативность
        </script>
      </section>
    </section>

    <!--#2. Понятия и термины-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #2. Понятия и термины
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker и ядро Linux
          - **Docker Engine** (сервис) - это программа позволяющая строить, поставлять и запускать контейнеры.

          <img src="img/docker_linux_kernel.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Linux
          ####Установка репозитория
          ```
          sudo apt-get update
          sudo apt-get install \
            apt-transport-https \
            ca-certificates \
            curl \
            gnupg-agent \
            software-properties-common
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
          sudo add-apt-repository \
            "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
            $(lsb_release -cs) \
            stable"
          ```
          ####Установка Docker CE
          ```
          sudo apt-get update
          sudo apt-get install docker-ce docker-ce-cli containerd.io
          ```
          <a href="https://docs.docker.com/install/" target="_blank">документация</a>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Windows и Mac OS X:
          Docker'у необходимо ядро linux... придется использовать виртуальную машину.

          Процесс установки подробно описан на сайте самого Docker'а:<br>
          <a href="https://docs.docker.com/docker-for-mac/install/" target="_blank">MAC</a> и
          <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank">Windows</a>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Или воспользуемся <a href="https://labs.play-with-docker.com/" target="_blank">play-with-docker</a>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Проверка работы docker
          ```
          $ sudo docker run hello-world
          ```
          Эта команда загрузит образ, создаст и запустит "Hello, World!" контейнер

          <i>/\*lets try\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker клиент и сервис
          - Клиент-серверная архитектура
          - Клиент получает команды от пользователя и отправляет их сервису
          - Сервис строит, запускает и распростроняет контейнеры
          - Клиент и сервис могут быть как на одной, так и на разных машинах
        </script>
      </section>

      <section>
        <img src="img/docker_client_daemon.png" alt="">
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Проверим версию клиента и сервиса
          ```
          $ docker version

          Client: Docker Engine - Community
          Version:           19.03.1
          API version:       1.40
          Go version:        go1.12.5
          ...
          Experimental:      false

          Server: Docker Engine - Community
          Engine:
          Version:          19.03.1
          API version:      1.40 (minimum version 1.12)
          Go version:       go1.12.5
          ...
          Experimental:     false
          ```
          <i>/\*lets see\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Образы и контейнеры
          **Образ (Image)**
          - Read-only шаблон для создания контейнера
          - Создан вами или другими участниками сообщества
          - Хранится на Docker Hub или любом другом Registry

          **Контейнер (Container)**
          - Изолированая платформа для приложения
          - Содержит все необходимое для запуска приложения
          - В основе его лежит Image
        </script>
      </section>

      <!--section data-markdown>
        <script type="text/template">
          Перед созданием "Hello, world!" контейнера, в локальную файловую систему скачался образ hello-world
          для последующих запусков он будет взят из локального хранилища. Можно посмотреть доступные локально образы:
          ```
          $ docker image ls
          REPOSITORY    TAG      IMAGE ID        CREATED        SIZE
          hello-world   latest   fce289e99eb9    4 months ago   1.84kB
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Список контейнеров можно посмотреть так:
          ```
          $ docker container ls --all
          CONTAINER ID  IMAGE        COMMAND   CREATED         STATUS
          929a5e54e8bf  hello-world  "/hello"  2 minutes ago   Exited (0) 2 minutes ago
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Повторный запуск команды
          ```
          $ sudo docker run hello-world
          ```
          создаст новый контейнер, образ же при этом останется один
          ```
          $ docker image ls
          REPOSITORY    TAG      IMAGE ID        CREATED        SIZE
          hello-world   latest   fce289e99eb9    4 months ago   1.84kB

          $ docker container ls --all
          CONTAINER ID  IMAGE        COMMAND   CREATED         STATUS
          634fa48be01c  hello-world  "/hello"  1 minutes ago  Exited (0) 1 minutes ago
          929a5e54e8bf  hello-world  "/hello"  2 minutes ago  Exited (0) 2 minutes ago
          ```
        </script>
      </section-->

      <section data-markdown>
        <script type="text/template">
          ##Registry и репозитории
          Registry - то место, где хранятся образы. Registry может быть приватным или публичным (Docker Hub)

          Внутри Registry находятся репозитории, в репозиториях лежат образы
          <img src="img/docker_registry_repository.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker оркестрация
          3 инструмента для оркестрации распределенных с помощью Docker приложений
          - Docker Machine
            - позволяет создавать и управлять Docker хостами
          - Docker Swarm
            - объединяет множества Docker Engine в кластеры
          - Docker Compose
            - позволяет создавать и управлять многоконтейнерными приложениями
        </script>
      </section>
    </section>

    <!--#3. Образы (Images)-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #3. Образы (Images)
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Поиск образов на Docker Hub
          - Множество образов доступны для использования
          - Образы лежат в различных репозиториях
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          <a href="https://hub.docker.com/search?q=&type=image" target="_blank">https://hub.docker.com/search</a>
          <img src="img/docker_explore_official_repo.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Показать локальные образы
          ```
          $ docker images
          ```
          - При создании контейнера Docker сначала пытается найти образ локально
          - Если нет локальной копии, Docker пойдет настроенный Registry или на Docker Hub (Registry по умолчанию)

          <i>/\*lets take a look\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Тэги Образов (Image Tags)
          - Образы идендифицируются по строке repository:tag
          - Один образ может иметь множество тэгов
          - Тэг по умолчанию - `latest`

          Традиционно в качестве тэга используется имя версии и/или используемых инструментов
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Тэги используемые для образов **openjdk**
          <img src="img/docker_openjdk_tags.png" alt="">
        </script>
      </section>
    </section>

    <!--#4. Знакомство с контейнерами-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #4. Знакомство с контейнерами
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Создание контейнера
          Используя `docker run`

          Синтаксис:
          ```
          $ docker run [options] [image] [command] [args]
          ```
          - image указывается как repository:tag

          Пример:
          ```
          sudo docker run ubuntu:14.04 ps aux
          ```
          <i>/\*Demo time\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Контейнер с терминалом
          Задейсвуем опции:
          - `-i, --interactive` флаг сообщает Docker'у, что нужно подключиться к STDIN контейнера
          - `-t, --tty` флаг сообщает Docker'у, что нужно использовать pseudo-terminal

          ###Пример
          ```
          docker run -i -t ubuntu /bin/bash
          ```
          <i>/\*Demo time\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Процессы внутри контейнера
          - Контейнер запущен пока запущен процесс из переданной команды (например: `/bin/bash`)
          - Процесс из переданной команды всегда имеет PID 1 внутри контейнера
          - Выход из контейнера без прерывания процесса: `ctrl + p + q`
        </script>
      </section>

      <section>
        <img src="img/docker_container_processes.png" alt="">
      </section>

      <section data-markdown>
        <script type="text/template">
          ##ID контейнера
          - Контейнер может быть идентифицирован по ID или именм
          - Короткому или длинному ID
          - Короткий ID и имя можно получить используя команду вывода списка контейнеров `docker ps`
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Где найти список своих контейнеров
          - команда `docker ps` покажет запущенные контейнеры
          - команда `docker ps -a` покажет все контейнеры, в т.ч. остановленные

          <i>/\*Take a look\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Запуск в фоновом режиме (Detached Mode)
          - Также известном как режим сервиса (Daemon)
          - Используйте флаг `-d, --detach`
          - Чтобы посмотреть STDOUT используйте `docker logs [container id]`

          <br>Пример:
          ```
          $ docker run -d alpine ping 127.0.0.1 -c 50
          29cbbcd1150f255769a549f4ef83a38a5216c2f06b1f5891530b4207266f8260

          $ docker logs 29cbbcd1150f255769a549f4ef83a38a5216c2f06b1f5891530b4207266f8260
          PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
          64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.041 ms
          ```

          <i>/\*Take a look\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Ports mapping
          - Запустим web приложение в контейнере
          - Используем флаг `-P, --publish-all` для маппинга портов из контейнера на хост

          <br>Пример:
          ```
          $ docker run -d -P tomcat
          ```
          <i>/\*Take a look\*/</i>
        </script>
      </section>
    </section>

    <!--#5. Создание образов-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #5. Создание образов
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Слои образов (Layers)
          - Образы состоят из множества слоев
          - Каждый слой это просто еще один образ
          - Каждый образ содержит базовый слой
          - Docker использует копию верхнего слоя для записи
          - Слои доступны только для чтения
        </script>
      </section>

      <section>
        <img src="img/docker_image_layers.png" alt="">
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Слой доступный для записи
          - Для контейнеров Docker создает верхний слой с разрешенными операциями записи
          - Родительский образ при этом с доступом Read-only
          - Все изменения делаются только на верхнем слое
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker commit
          - Команда `docker commit` сохраняет измененный контейнер как новый образ
          ```
          docker commit [options] [container ID] [repository:tag]
          ```
          - Имя репозитория должно быть вида `username/application`
          - В качестве ссылки на контейнер может использоваться не только его ID, но и имя
          ```
          docker commit [id] person/samba:1.0
          ```

          >Тэг по умолчанию - latest
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          <i>/\*lets try commit and run\*/</i>
          ```
          docker run --name ubuntu1 -it ubuntu
          # ls
          # touch all-my-passwords
          # ls
          # exit

          docker commit ubuntu1 user/my-secret-file
          docker run -it user/my-secret-file
          ```
          Посмотреть локальные образы
          ```
          docker images
          ```
          Выгрузка образа в Registry
          ```
          docker push user/my-secret-file
          ```
        </script>
      </section>
    </section>

    <!--#6. Dockerfile-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #6. Dockerfile
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Введение в Dockerfile
          >**Dockerfile** - это конфигурационный файл содержащий инструкции для сборки Docker образа

          - Предоставляет более удобный метод для сборки образов, чем `docker commit`
          - Легко встраивается в CI/CD процесс
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкции Dockerfile
          - Инструкции определяют, что необходимо делать для сборки образа
          - Инструкция FROM определяет какой базовый образ использовать
          - Инструкция RUN определяет команду для исполнения

          Пример:
          ```
          FROM ubuntu:14.04
          RUN apt-get install -y vim
          RUN apt-get install -y curl
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкция Run
          - Каждая инструкция RUN будет выполнена не верхнем (writable) слое и сделает commit получившегося образа
          - Может содержать последовательность команд объединенных через `&&`

          Пример:
          ```
          RUN apt-get update && apt-get install -y curl vim
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker Build
          - Синтаксис
          <br>
          `docker build [options] [path]`
          - Часто используется с опцией присвоения имени (и тэга)
          <br>
          `docker build -t [repository:tag] [path]`

          -t (--tag) для задания имени
          <br>
          path - build context
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Build context
          - При использовании ссылок на файлы в инструкциях - файлы должны находиться в build context
          - Во время сборки Docker-клиент упакует файлы контекста и отправит их Docker-сервису
          - Это также то самое место, где docker будет искать Dockerfile.
          <br>
          По умолчанию - это файл с именем Dockerfile в корневой папке контекста (-f, --file - для переопределения)
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Пример:
          ```
          $ cd files/build-vim && docker build -t your-docker-id/vim:1.2 .
          #or
          $ docker build -t your-docker-id/vim:1.2 files/build-vim
          ```

          <i>/\*lets try\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Вывод:
          ```
          $ cat Dockerfile
          FROM ubuntu:14.04
          RUN apt-get update && apt-get install -y vim

          $ docker build -t your-docker-id/vim:1.2 files/build-vim
          Sending build context to Docker daemon 2.048 kB
          Step 0 : FROM ubuntu:14.04
           ---> f216cfb59484
          Step 1 : RUN apt-get update && apt-get install -y vim
           ---> Running in 8cd9a9ac0b1d
          ...
          #install logs
          ...
          Removing intermediate container 8cd9a9ac0b1d
           ---> 35217bd61152
          Successfully built 35217bd61152
          Successfully tagged your-docker-id/vim:1.2
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкция CMD
          - CMD определят какая команда будет выполнена по умолчанию при создании контейнера
          - CMD не выполняет действий во время сборки образа
          - Поддерживает Shell и EXEC форматы
          - Может быть определена только один раз в пределах Dockerfile
          - **Может быть переопределена при запуске контейнера**

          ```
          #Shell format
          CMD ping 127.0.0.1 -c 30
          #Exec format (json)
          CMD ["ping", "127.0.0.1", "-c", "30"]
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Пример

          ```
          $ cat Dockerfile
          FROM ubuntu:14.04
          RUN apt-get update && apt-get install -y vim
          CMD ["ping", "127.0.0.1", "-c", "30"]
          ```
          ```
          $ docker build -t your-docker-id/vim:1.3 files/build-vim-ping-cmd
          Sending build context to Docker daemon 2.048 kB
          Step 0 : FROM ubuntu:14.04
           ---> 91e54dfb1179
          Step 1 : RUN apt-get update && apt-get install -y vim
           ---> Using cache
           ---> 35217bd61152
          Step 2 : CMD ping 127.0.0.1 -c 30
           ---> Running in edcb94bb0c12
          Removing intermediate container edcb94bb0c12
          ---> 989fb2bf2f41
          Successfully tagged your-docker-id/vim:1.3
          ```
          Добавление слоев происходит значительно быстрее первоначальной сборки
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Инструкция ENTRYPOINT
          - Определят какая команда будет выполнена при запуске контейнера
          - Runtime аргументы и инструкция CMD передаются как параметры в инструкцию ENTRYPOINT
          - Поддерживает Shell и EXEC форматы
          - EXEC формат предпочтительнее, т.к. shell формат не может принимать аргументы в runtime
          <!-- - Container essentially runs as an executable-->
          - ENTRYPOINT не может быть переопределена при запуске
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Пример
          Dockerfile
          ```
          $ cat Dockerfile
          FROM ubuntu:14.04
          RUN apt-get update && apt-get install -y vim
          ENTRYPOINT ["ping"]
          ```
          сборка образа
          ```
          $ docker build -t your-docker-id/vim:1.4 files/build-vim-ping-ep
          Sending build context to Docker daemon 2.048 kB
          Step 0 : FROM ubuntu:14.04
           ---> 91e54dfb1179
          Step 1 : RUN apt-get update && apt-get install -y vim
           ---> Using cache
           ---> 58c42776c9b7
          Step 2 : ENTRYPOINT ping
           ---> Running in d8ffe9f42f9d
           ---> 4f940463520e
          Removing intermediate container d8ffe9f42f9d
          Successfully built 4f940463520e
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Как использовать
          ```bash
          $ docker run your-docker-id/vim:1.4
          Usage: ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]
          [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]
          [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]
          [-w deadline] [-W timeout] [hop1 ...] destination

          $ docker run your-docker-id/vim:1.4 127.0.0.1 -c 10
          PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
          64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.032 ms
          #...
          64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.038 ms

          --- 127.0.0.1 ping statistics ---
          10 packets transmitted, 10 received, 0% packet loss, time 8996ms
          rtt min/avg/max/mdev = 0.032/0.041/0.050/0.004 ms
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          <img src="img/cmd-entrypoint.png" alt="">
        </script>
      </section>
    </section>

    <!--#7. Управление образами и контейнерами-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #7. Управление образами и контейнерами
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Запуск и остановка контейнеров
          - Сначала найдите ID нужного контейнера с помощью `docker ps`
          - 'docker start' и 'docker stop' для запуска и остановки

          ```
          $ docker ps -a
          CONTAINER ID   IMAGE         ...        CREATED    ...   STATUS
          6aacd72967b8   your-docker-id/vim:1.2   25 minutes ago   Exited (0) 25 minutes ago
          $ docker start 6aacd72967b8
          $ docker stop 6aacd72967b8
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Подключение к терминалу
          - Для запуска **нового процесса** внутри контейнера используйте команду `exec`
          - Для запуска командной оболочки выполните `/bin/bash`
          - `docker exec -i -t [container ID] /bin/bash`
          - Выход из терминал **не** завершит работу контейнера

          <i>/\*lets try у нас запущен tomcat\*/</i>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Удаление контейнеров
          - Могут быть удалены только остановленные контейнеры
          - Для удаления контейнеров используется команда `docker rm`
          - Следует указывать имя или ID контейнера
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Удаление локальных образов
          - Для удаления образов используется команда `docker rmi`
          - **docker rmi [ID образа]**<br>
          или<br>
          **docker rmi [repo:tag]**
          - Если образ имеет несколько тэгов, нужно удалить каждый
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Переименование и тэгирование образов
          `docker tag [image ID] [repo:tag]`<br>
          или<br>
          `docker tag [local repo:tag] [Docker Hub repo:tag]`
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker Hub Репозитории
          - Пользователи могут создавать собственные репозитории на Docker Hub
          - Публичные и частные
          - Выгружать локальные образы в репозитории
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Выгрузка образов на Docker Hub
          Используйте команду `docker push`
          ```
          docker push [repo:tag]
          ```
          - Локальный репозиторий должен иметь то же имя и тэг как и репозиторий на Docker Hub
        </script>
      </section>
    </section>

    <!--#8. Тома-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #8. Volumes (Тома данных)
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Volumes (Тома данных)
          >Том - это определенная директория внутри контейнера, предназначенная для длительного хранения данных и
          независимая от жизненного цикла контейнера

          - Изменения в томах не затрагиваются при обновлении образа
          - Тома сохраняются при удалении контейнера
          - Том может быть подключен в директорию host машины
          - Том может быть доступен нескольким контейнерам
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Монтирование тома
          - Тома монтируются при создании или запуске контейнера
          - Путь к тому должен быть абсолютным
          ```
          # Запуск нового контейнера и монтирование именованого тома
          # 'testvolume' в директорию /myvolume его файловой системы
          docker run -d -P -v testvolume:/myvolume nginx:1.9.4
          ```
          ```
          # Запуск нового контейнера и маппинг директории /data/src
          # с host машины в директорию /test/src контейнера
          docker run -i -t -v /data/src:/test/src nginx:1.9.4
          ```
          ```
          # Запуск нового контейнера и маппинг директории target из
          # текущей директории
          mkdir target
          docker run -d -v "$(pwd)"/target:/app nginx
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Тома в Dockerfile
          - Инструкция VOLUME создает точку монтирования
          - Может принимать JSON массив или строку в качестве аргумента
          - Не может подключать тома к директориям host машины
          - Тома инициализируются при запуске контейнера
          ```
          # Использование строки
          VOLUME /myvol
          # Использование строки для создания множества томов
          VOLUME /www/website1.com /www/website2.com
          # Использование JSON массива
          VOLUME ["myvol", "myvol2"]
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Использование томов
          - Отделение данных для длительного хранения от контейнера который эти данные создает (например логи)
          - Отлично подходит для разделения данных между несколькими контейнерами
          - Монтирование директорий с host машины полезно на этапе тестирования, но обычно не рекомендуется для
          использования в реальной эксплуатации
        </script>
      </section>
    </section>

    <!--#9. Работа с сетью-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #9. Работа с сетью
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Маппинг портов
          - **Внимание**: у контейнера есть собственная сеть и IP адрес
          - Маппинг пробрасывает порты контейнера на порты host машины
          - Порты могут быть проброшены автоматически или вручную
          - Для маппинга используются ключи -p (--publish [list]) и -P (--publish-all) команды `docker run`
          ```
          # Пробросить порт 80 контейнера на порт 8080 хоста
          docker run -d -p 8080:80 nginx:1.9.4
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Авто-маппинг портов
          - Используйте ключ -P (--publish-all) команды `docker run`
          - Автоматический маппинг пробрасывает порты из контейнера на хост
          - Для авто-маппинга на хосте используются порты от 32768 до 61000
          - Проброс работает толкео для портов обозначенных в инструкции EXPOSE
          ```
          $ docker run -d -P nginx:1.9.4
          $ docker ps
          IMAGE        COMMAND         ...      PORTS
          nginx:1.9.4  "nginx -g 'daemon of…"   0.0.0.0:32774->80/tcp, 0.0.0.0:32773->443/tcp
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкция EXPOSE
          - Определяет какие порты контейнер слушает во время работы
          - Порты должны быть не только объявлены, но также должен быть настроен маппинг портов

          ```
          FROM ubuntu:14.04
          RUN apt-get update
          RUN apt-get install -y nginx

          EXPOSE 80 443

          CMD ["nginx","-g","daemon off;"]
          ```
          ```
          docker build -t my-nginx .
          docker run -d -p 80:80/tcp -p 443:443/tcp my-nginx
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Сети типа мост (bridge)
          > Применимо к Docker, сети такого типа, или просто "бриджи", позволяют контейнерам подключенным к одному
            bridge обмениваться информацией и быть в то же время изолированными от других контейнеров которые к этому
            bridge не подключены.
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Bridge по умолчанию
          Этот bridge создается как только запускается Docker. Все вновь созданные контейнеры подключаются к нему,
          если явно не указано другое поведение.
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Пользовательские bridge
          - Пользовательские бриджи обеспечивают лучшую изоляцию и большую совместимость между приложениями;
          - Контейнеры подключенные к одному пользовательскому бриджу автоматически открывают друг для друга все порты,
            при этом снаружи все порты остаются закрытыми без явного указания другого поведения;
          - Пользовательские бриджи автоматически предоставляют сервис DNS для разрешения имен контейнеров внутри
            бриджа;
          - Контейнеры могут обращаться друг к другу по имени или псевдониму;
          - Контейнеры могут быть подключены и отключены от бриджа в любой момент.
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Создание пользовательского бриджа

          `$ docker network create my-net`

          Опции создания можно посмотреть командой

          `$ docker network create --help`

          ---
          Удалить пользовательский бридж

          `$ docker network rm my-net`
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Подключение контейнера к бриджу при создании

          `$ docker create --name my-nginx --network my-net --publish 8080:80 nginx:latest`

          ---
          Подключение работающего контейнера к бриджу

          `$ docker network connect my-net my-nginx`

          Отключение контейнера от бриджа

          `$ docker network disconnect my-net my-nginx`
        </script>
      </section>
    </section>

    <!--#10. CI-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #10. Docker в Continuous Integration (CI)
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Традиционная Continuous Integration
          <img src="img/docker_traditional_continuous_integration.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Использование Docker в CI. Метод 1
          CI сервер собирает образы Docker и выкладывает их на Docker Hub
          <img src="img/docker_in_CI.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker Hub автоматически собирает образы. Метод 2
          Docker Hub обнаруживает новые коммиты в репозиторий исходного кода и собирает новый образ
          <img src="img/docker_hub_auto_build.png" alt="">
        </script>
      </section>
    </section>

    <!--#11. Docker Compose-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #11. Docker Compose
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          >Docker **Compose** это инструмент для создания и управления мультиконтейнерными приложениями

          - Все контейнеры объявляются в одном файле "docker-compose.yml"
          - Каждый контейнер представляет собой один компонент (сервис, микросервис) приложения
          <br>Например: Web front end / Аутентификация пользователей / Платежи / База данных
          - Compose развернет все сервисы одной командой
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Конфигурация yml файла для Compose
          - Определяет сервисы из которых состоит приложение
          - Каждый сервис содержит инструкции для сборки и запуска контейнера

          ```
          version: '3'
          services:
            curl:
              build: .
            http:
              image: briceburg/ping-pong
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкции Build и Image
          - **Build** задает путь к Dockerfile который будет использоваться для создания образа
          - Контейнер будет запущен используя созданный образ
          - **Image** задает образ который будет использован для создания контейнера
          - Каждый сервис должен иметь одну из инструкций build или image

          ```
          version: '3'
          services:
            curl:
              build: .
            http:
              image: briceburg/ping-pong
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Запуск приложения
          - Используется команда `docker-compose up`
          - Команда `up`:
            - Создаст или скачает образ для каждого сервиса
            - Создаст и запустит контейнеры
        </script>
      </section>
    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ##Sources and reference:
          <br/>
          https://docs.docker.com/

          https://docs.docker.com/get-started/

          <img src="img/qr-io.png" alt="">
        </script>
      </section>
    </section>

    <section>
      <section data-markdown>
        <script type="text/template">
          ### Автор
          <br><br>
          Артем Колин
          <br><br>
          Инженер программист, компания Eltex
          <br><br>
          https://t.me/artemkaxboy
        </script>
      </section>
    </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
        ]
        });

      </script>

  </body>
</html>
