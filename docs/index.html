<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>Docker</title>

  <meta name="description" content="Docker workshop slides">
  <meta name="author" content="Artem Kolin">
  <meta name="author" content="Loic Delestra">

  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <!-- <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /> -->

  <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"> -->

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/beige.css" id="theme">

  <link rel="stylesheet" href="css/custom.css">


  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- Printing and PDF exports -->
  <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>

<body>

<div class="reveal">

  <!-- Any section element inside of this container is displayed as a slide -->
  <div class="slides">
    <section data-markdown>
      <script type="text/template">
        # Docker
      </script>
    </section>

    <!--#1. Введение-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #1. Введение
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Что это ?
          Docker - это платформа для разработки, поставки и запуска приложений с использованием технологии
          контейнерной виртуализации.
          <br>
          <br>
          Платформа Docker содержит ряд различных утилит.
          <br>
          <br>
          >Docker
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Что это ?
          Docker - это программное обеспечение для автоматизации развёртывания и управления приложениями в средах с
          поддержкой контейнеризации. Позволяет «упаковать» приложение со всем его окружением и зависимостями в
          контейнер, который может быть перенесён на любую Linux-систему
          <br>
          <br>
          >Wikipedia
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          #История
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Одно приложение на одном физическом сервере
          <img src="img/docker_one_app_one_server.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Недостатки
          - Длительное время развертывания
          - Огромные цена
          - Простой ресурсов
          - Сложности масштабирования и миграции
          - Vendor Lock
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Hypervisor
          - Один физический сервер может содержать несколько независимых приложений
          - Каждое приложение изолировано внутри своей VM

          <img src="img/docker_hypervisor_based_virtualization.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Преимущества
          - Лучшее распределение ресурсов
          - один физический сервер разделен на ряд VM
          - Легче масштабировать
          - Легко перенести
          - Можно запустить в облаке
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Ограничения
          - Для каждой VM по прежнему требуется
          - выделение CPU
          - хранилище
          - RAM
          - установка гостевой ОС
          - Чем больше VM запускаешь, тем больше нужно ресурсов
          - Гостевая OС впустую потребляет ресурсы
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Контейнеры
          >Контейнерная виртуализация использует ядро основной ОС для запуска множества экземпляров гостевых ОС

          - Каждый экземпляр гостевой ОС называется контейнер
          - Каждый контейнер имеет собственные
          - корневую файловую систему
          - процессы
          - память
          - сетевые порты
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Контейнеры
          <img src="img/docker_containers_oskernel.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Преимущества контейнеров перед VM
          - Легковесны
          - Не требуют установки гостевой ОС
          - Меньшее потребление CPU, RAM, хранилища
          - Можно запустить большее количество контейнеров на одной машине
          - Бо́льшая портативность
        </script>
      </section>
    </section>

    <!--#2. Понятия и термины-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #2. Понятия и термины
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker и ядро Linux
          - **Docker Engine** (сервис) - это программа позволяющая строить, поставлять и запускать контейнеры.

          <img src="img/docker_linux_kernel.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Установка
          Для удобства мы будем использовать
          <a href="https://labs.play-with-docker.com/" target="_blank">готовую облачную среду</a>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Linux
          ####Установка репозитория
          ```
          sudo apt-get update
          sudo apt-get install \
            apt-transport-https \
            ca-certificates \
            curl \
            gnupg-agent \
            software-properties-common
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
          sudo add-apt-repository \
            "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
            $(lsb_release -cs) \
            stable"
          ```
          ####Установка Docker CE
          ```
          sudo apt-get update
          sudo apt-get install docker-ce docker-ce-cli containerd.io
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Windows и Mac OS X:
          Docker'у необходимо ядро linux... придется использовать виртуальную машину.

          Процесс установки подробно описан на сайте самого Docker'а:<br>
          <a href="https://docs.docker.com/docker-for-mac/install/" target="_blank">MAC</a> и
          <a href="https://docs.docker.com/docker-for-windows/install/" target="_blank">Windows</a>
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Проверка работы docker
          ```
          $ sudo docker run hello-world
          ```
          Эта команда загрузит образ, создаст и запустит "Hello, World!" контейнер

          /\*lets try\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker клиент и сервис
          - Клиент-серверная архитектура
          - Клиент получает команды от пользователя и отправляет их сервису
          - Сервис строит, запускает и распростроняет контейнеры
          - Клиент и сервис могут быть как на одной, так и на разных машинах
        </script>
      </section>

      <section>
        <img src="img/docker_client_daemon.png" alt="">
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Проверим версию клиента и сервиса
          ```
          $ docker version
          ```
          /\*lets see\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Образы и контейнеры
          **Образ (Image)**
          - Read-only шаблон для создания контейнера
          - Создан вами или другими участниками сообщества
          - Хранится на Docker Hub или любом другом Registry

          **Контейнер (Container)**
          - Изолированая платформа для приложения
          - Содержит все необходимое для запуска приложения
          - В основе его лежит Image
        </script>
      </section>

      <!--section data-markdown>
        <script type="text/template">
          Перед созданием "Hello, world!" контейнера, в локальную файловую систему скачался образ hello-world
          для последующих запусков он будет взят из локального хранилища. Можно посмотреть доступные локально образы:
          ```
          $ docker image ls
          REPOSITORY    TAG      IMAGE ID        CREATED        SIZE
          hello-world   latest   fce289e99eb9    4 months ago   1.84kB
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Список контейнеров можно посмотреть так:
          ```
          $ docker container ls --all
          CONTAINER ID  IMAGE        COMMAND   CREATED         STATUS
          929a5e54e8bf  hello-world  "/hello"  2 minutes ago   Exited (0) 2 minutes ago
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Повторный запуск команды
          ```
          $ sudo docker run hello-world
          ```
          создаст новый контейнер, образ же при этом останется один
          ```
          $ docker image ls
          REPOSITORY    TAG      IMAGE ID        CREATED        SIZE
          hello-world   latest   fce289e99eb9    4 months ago   1.84kB

          $ docker container ls --all
          CONTAINER ID  IMAGE        COMMAND   CREATED         STATUS
          634fa48be01c  hello-world  "/hello"  1 minutes ago  Exited (0) 1 minutes ago
          929a5e54e8bf  hello-world  "/hello"  2 minutes ago  Exited (0) 2 minutes ago
          ```
        </script>
      </section-->

      <section data-markdown>
        <script type="text/template">
          ##Registry и репозитории
          Registry - то место, где хранятся образы. Registry может быть приватным или публичным (Docker Hub)

          Внутри Registry находятся репозитории, в репозиториях лежат образы
          <img src="img/docker_registry_repository.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker оркестрация
          3 инструмента для оркестрации распределенных с помощью Docker приложений
          - Docker Machine
            - позволяет создавать и управлять Docker хостами
          - Docker Swarm
            - объединяет множества Docker Engine в кластеры
          - Docker Compose
            - позволяет создавать и управлять многоконтейнерными приложениями
        </script>
      </section>
    </section>

    <!--#3. Образы (Images)-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #3. Образы (Images)
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Поиск образов на Docker Hub
          - Множество образов доступны для использования
          - Образы лежат в различных репозиториях
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          <a href="https://hub.docker.com/search?q=&type=image" target="_blank">https://hub.docker.com/search</a>
          <img src="img/docker_explore_official_repo.png" alt="">
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Показать локальные образы
          ```
          $ docker images
          ```
          - При создании контейнера Docker сначала пытается найти образ локально
          - Если нет локальной копии, Docker пойдет настроенный Registry или на Docker Hub (Registry по умолчанию)

          /\*lets take a look\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Тэги Образов (Image Tags)
          - Образы идендифицируются по строке repository:tag
          - Один образ может иметь множество тэгов
          - Тэг по умолчанию - `latest`

          Традиционно в качестве тэга используется имя версии и/или используемых инструментов
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Тэги используемые для образов **openjdk**
          <img src="img/docker_openjdk_tags.png" alt="">
        </script>
      </section>
    </section>

    <!--#4. Знакомство с контейнерами-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #4. Знакомство с контейнерами
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Создание контейнера
          Используя `docker run`

          Синтаксис:
          ```
          $ docker run [options] [image] [command] [args]
          ```
          - image указывается как repository:tag

          Пример:
          ```
          sudo docker run ubuntu:14.04 ps aux
          ```
          /\*Demo time\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Контейнер с терминалом
          Задейсвуем опции:
          - `-i, --interactive` флаг сообщает Docker'у, что нужно подключиться к STDIN контейнера
          - `-t, --tty` флаг сообщает Docker'у, что нужно использовать pseudo-terminal

          ###Пример
          ```
          docker run -i -t ubuntu /bin/bash
          ```
          /\*Demo time\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Процессы внутри контейнера
          - Контейнер запущен пока запущен процесс из переданной команды (например: `/bin/bash`)
          - Процесс из переданной команды всегда имеет PID 1 внутри контейнера
          - Выход из контейнера без прерывания процесса: `ctrl + p + q`
        </script>
      </section>

      <section>
        <img src="img/docker_container_processes.png" alt="">
      </section>

      <section data-markdown>
        <script type="text/template">
          ##ID контейнера
          - Контейнер может быть идентифицирован по ID или именм
          - Короткому или длинному ID
          - Короткий ID и имя можно получить используя команду вывода списка контейнеров `docker ps`
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Где найти список своих контейнеров
          - команда `docker ps` покажет запущенные контейнеры
          - команда `docker ps -a` покажет все контейнеры, в т.ч. остановленные

          /\*Take a look\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Запуск в фоновом режиме (Detached Mode)
          - Также известном как режим сервиса (Daemon)
          - Используйте флаг `-d, --detach`
          - Чтобы посмотреть STDOUT используйте `docker logs [container id]`

          <br>Пример:
          ```
          $ docker run -d ubuntu ping 127.0.0.1 -c 50
          29cbbcd1150f255769a549f4ef83a38a5216c2f06b1f5891530b4207266f8260

          $ docker logs 29cbbcd1150f255769a549f4ef83a38a5216c2f06b1f5891530b4207266f8260
          PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
          64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.041 ms
          ```

          /\*Take a look\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Ports mapping
          - Запустим web приложение в контейнере
          - Используем флаг `-P, --publish-all` для маппинга портов из контейнера на хост

          <br>Пример:
          ```
          $ docker run -d -P tomcat
          ```
          /\*Take a look\*/
        </script>
      </section>
    </section>

    <!--#5. Создание образов-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #5. Создание образов
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Слои образов (Layers)
          - Образы состоят из множества слоев
          - Каждый слой это просто еще один образ
          - Каждый образ содержит базовый слой
          - Docker использует копию верхнего слоя для записи
          - Слои доступны только для чтения
        </script>
      </section>

      <section>
        <img src="img/docker_image_layers.png" alt="">
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Слой доступный для записи
          - Для контейнеров Docker создает верхний слой с разрешенными операциями записи
          - Родительский образ при этом с доступом Read-only
          - Все изменения делаются только на верхнем слое
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker commit
          - команда `docker commit` сохраняет измененный контейнер как новый образ
          ```
          docker commit [options] [container ID] [repository:tag]
          ```
          - Имя репозитория должно быть вида `username/application`
          - В качестве ссылки на контейнер может использоваться не только его ID, но и имя
          ```
          docker commit [id] person/samba:1.0
          ```

          >Тэг по умолчанию - latest

          /\*lets try commit and run\*/
        </script>
      </section>
    </section>

    <!--#6. Dockerfile-->
    <section>
      <section data-markdown>
        <script type="text/template">
          #6. Dockerfile
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Введение в Dockerfile
          >**Dockerfile** - это конфигурационный файл содержащий инструкции для сборки Docker образа

          - Предоставляет более удобный метод для сборки образов, чем `docker commit`
          - Легко встраивается в CI/CD процесс
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкции Dockerfile
          - Инструкции определяют, что необходимо делать для сборки образа
          - Инструкция FROM определяет какой базовый образ использовать
          - Инструкция RUN определяет команду для исполнения

          Пример:
          ```
          FROM ubuntu:14.04
          RUN apt-get install -y vim
          RUN apt-get install -y curl
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкция Run
          - Каждая инструкция RUN будет выполнена не верхнем (writable) слое и сделает commit получившегося образа
          - Может содержать последовательность команд объединенных через `&&`

          Пример:
          ```
          RUN apt-get update && apt-get install -y curl vim
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Docker Build
          - Синтаксис
          <br>
          `docker build [options] [path]`
          - Часто используется с опцией присвоения имени (и тэга)
          <br>
          `docker build -t [repository:tag] [path]`

          -t (--tag) для задания имени
          <br>
          path - build context
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Build context
          - При использовании ссылок на файлы в инструкциях - файлы должны находиться в build context
          - Во время сборки Docker-клиент упакует файлы контекста и отправит их Docker-сервису
          - Это также то самое место, где docker будет искать Dockerfile.
          <br>
          По умолчанию - это файл с именем Dockerfile в корневой папке контекста (-f, --file - для переопределения)
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Пример:
          ```
          $ cd files/build-vim && docker build -t your-docker-id/vim:1.2 .
          #or
          $ docker build -t your-docker-id/vim:1.2 files/build-vim
          ```

          /\*lets try\*/
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Вывод:
          ```
          $ cat Dockerfile
          FROM ubuntu:14.04
          RUN apt-get update && apt-get install -y vim

          $ docker build -t your-docker-id/vim:1.2 files/build-vim
          Sending build context to Docker daemon 2.048 kB
          Step 0 : FROM ubuntu:14.04
           ---> f216cfb59484
          Step 1 : RUN apt-get update && apt-get install -y vim
           ---> Running in 8cd9a9ac0b1d
          ...
          #install logs
          ...
          Removing intermediate container 8cd9a9ac0b1d
           ---> 35217bd61152
          Successfully built 35217bd61152
          Successfully tagged your-docker-id/vim:1.2
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ##Инструкция CMD
          - CMD определят какая команда будет выполнена по умолчанию при создании контейнера
          - CMD не выполняет действий во время сборки образа
          - Поддерживает Shell и EXEC форматы
          - Может быть определена только один раз в пределах Dockerfile
          - **Может быть переопределена при запуске контейнера**

          ```
          #Shell format
          CMD ping 127.0.0.1 -c 30
          #Exec format (json)
          CMD ["ping", "127.0.0.1", "-c", "30"]
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Example

          ```
          $ cat Dockerfile
          FROM ubuntu:14.04
          RUN apt-get update && apt-get install -y vim
          CMD ["ping", "127.0.0.1", "-c", "30"]
          ```
          ```
          $ docker build -t your-docker-id/vim:1.3 files/build-vim-ping-cmd
          Sending build context to Docker daemon 2.048 kB
          Step 0 : FROM ubuntu:14.04
           ---> 91e54dfb1179
          Step 1 : RUN apt-get update && apt-get install -y vim
           ---> Using cache
           ---> 35217bd61152
          Step 2 : CMD ping 127.0.0.1 -c 30
           ---> Running in edcb94bb0c12
          Removing intermediate container edcb94bb0c12
          ---> 989fb2bf2f41
          Successfully tagged your-docker-id/vim:1.3
          $
          ```
          Adding a layer is very faster than building first image
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Инструкция ENTRYPOINT
          - Определят какая команда будет выполнена при запуске контейнера
          - Runtime аргументы и инструкция CMD передаются как параметры в инструкцию ENTRYPOINT
          - Поддерживает Shell и EXEC форматы
          - EXEC формат предпочтительнее, т.к. shell формат не может принимать аргументы в runtime
          <!-- - Container essentially runs as an executable-->
          - ENTRYPOINT не может быть переопределена при запуске
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          ###Пример
          Dockerfile
          ```
          $ cat Dockerfile
          FROM ubuntu:14.04
          RUN apt-get update && apt-get install -y vim
          ENTRYPOINT ["ping"]
          ```
          сборка образа
          ```
          $ docker build -t your-docker-id/vim:1.4 files/build-vim-ping-ep
          Sending build context to Docker daemon 2.048 kB
          Step 0 : FROM ubuntu:14.04
           ---> 91e54dfb1179
          Step 1 : RUN apt-get update && apt-get install -y vim
           ---> Using cache
           ---> 58c42776c9b7
          Step 2 : ENTRYPOINT ping
           ---> Running in d8ffe9f42f9d
           ---> 4f940463520e
          Removing intermediate container d8ffe9f42f9d
          Successfully built 4f940463520e
          ```
        </script>
      </section>

      <section data-markdown>
        <script type="text/template">
          Как использовать
          ```bash
          $ docker run your-docker-id/vim:1.4
          Usage: ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface]
          [-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos]
          [-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option]
          [-w deadline] [-W timeout] [hop1 ...] destination
          $ docker run your-docker-id/vim:1.4 127.0.0.1 -c 10
          PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
          64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.032 ms
          #...
          64 bytes from 127.0.0.1: icmp_seq=10 ttl=64 time=0.038 ms

          --- 127.0.0.1 ping statistics ---
          10 packets transmitted, 10 received, 0% packet loss, time 8996ms
          rtt min/avg/max/mdev = 0.032/0.041/0.050/0.004 ms
          ```
        </script>
      </section>
    </section>

        <section>

          <section data-markdown>
            <script type="text/template">
              #7. Managing Images and Containers
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Start and Stop Containers
              - Find your containers first with docker ps and note the ID or name
              - 'docker start' and 'docker stop'

              ```bash
              $ docker ps -a
              $ docker start <container ID>
              $ docker stop <container ID>
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Getting terminal access
              - Use docker `exec` command to **start another process** within a container
              - Execute /bin/bash to get a bash shell
              - `docker exec -i -t [container ID] /bin/bash`
              - Exiting from the terminal will **not** terminate the container

              /\*lets try with tomcat\*/
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Deleting Containers
              - Can only delete containers that have been stopped
              - Use `docker rm` command
              - Specify the container ID or name
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Deleting local Images
              - Use docker rmi command
              - **docker rmi [image ID]**<br>or<br>**docker rmi [repo:tag]**
              - if an image is tagged multiple times, you have to delete each tag
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Renaming Tagging Images

              `docker tag [image ID] [repo:tag]`
              <br>
              or
              <br>
              `docker tag [local repo:tag] [Docker Hub repo:tag]`
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Docker Hub Repositories
              - Users can create their own repositories on Docker Hub
              - Public and Private (one free)
              - Push local images to a repository
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Pushing images to Docker Hub

              Use `docker push` command

              ```
              docker push [repo:tag]
              ```
              <br>
              - Local repo must have same name and tag as the Docker Hub repo
            </script>
          </section>
        </section>

        <section>

          <section data-markdown>
            <script type="text/template">
              #8. Volumes
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Volumes
              >A volumes is a designated directory in a container, wich is designed to persist data, independent of the container's file cycle

              - Volume changes are excluded when updating an image
              - Persist when a container is deleted
              - Can be mapped to a host folder
              - Can be shared between containers
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Mount a Volume
              - Volumes are mounted when creating or executing a container
              - Can be mapped to a host directory
              - Volume paths specified must be absolute

              ```
              #Execute a new container and mount the named volume 'testvolume' to the folder /myvolume into its file system
              docker run -d -P -v testvolume:/myvolume nginx:1.9.4
              #Execute a new container and map the /data/src folder from the host into the /test/src folder in the container
              docker run -i -t -v /data/src:/test/src nginx:1.9.4
              docker run -d -v "$(pwd)"/target:/app nginx
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Volumes in Dockerfile
              - VOLUME instruction creates a mount point
              - Can specify arguments JSON array or string
              - Cannot map volumes to host directories
              - Volumes are initialized when the container is executed

              ```
              #String example
              VOLUME /myvol
              #String example with multiple volumes
              VOLUME /www/website1.com /www/website2.com
              #JSON example
              VOLUME ["myvol", "myvol2"]
              ```

            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Uses of volumes
              - De-couple the data that is stored from the container which created the data (exemple logs)
              - Good for sharing data between containers
                - Can setup a data containers which has a volume you mount in other containers
              - Mounting folders from the host is good for testing purpose but generally not recommended for production use
            </script>
          </section>
        </section>

        <section>

          <section data-markdown>
            <script type="text/template">
              #9. Container Networking Basics
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Mapping ports
              - **Recall:** containers have their own network and IP address
              - Map exposed container ports to ports on the host machine
              - Ports can be manually mapped or auto mapped
              - Uses the -p and -P parameters in `docker run`

              ```
              #Maps port 80 on the container to 8080 on the host
              docker run -d -p 8080:80 nginx:1.9.4
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Automapping ports
              - Use the -P option in **docker run**
              - Automatically maps exposed ports in the container to a port number in the host
              - Host port numbers used go from 49153 to 65535
              - Only work for ports defined in the EXPOSE instruction

              ```
              #Auto map ports exposed by the NGINX container to a port value on the host
              docker run -d -P nginx:1.9.4
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##EXPOSE instruction
              - Configures which ports a container will listen on at runtime
              - Ports still need to be mapped when container is executed

              ```
              FROM ubuntu:14.04
              RUN apt-get update
              RUN apt-get install -y nginx

              EXPOSE 80 443

              CMD ["nginx","-g","daemon off;"]
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Linking Containers (Legacy)
              >**Linking** is a communication method between containers which allows them to securely transfer data from one to another

              - Source and recipient containers
              - Recipient containers have access to data on source containers
              - Links are established based on container names
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              <img src="img/docker_linking_containers.png" alt="">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Creating a Link
              1. Create the source container first (database)
              2. Create the recipient container and use the --link option

              ```
              #Create the source container using the postgres
              docker run -d --name database postgres

              #Create the recipient container and link it
              docker run -d -P --name website --link database:db nginx
              # "db" is an alias added in /etc/hosts
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Uses of Linking
              - Containers can talk to each other without having to expose ports to the host
              - Essential for micro service application architecture
              - Пример:
                - Container with Tomcat running
                - Container with MySQL running
                - Application on Tomcat needs to connect to MySQL
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##bridge networks
              >In terms of Docker, a bridge network allows containers connected to the same bridge network to communicate, while providing isolation from containers which are not connected to that bridge network.
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ###Default bridge
              Create by default when you start Docker and newly-started containers connect to it unless otherwise specified.
              - Containers can only access each other by IP addresses, unless you use the --link option
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ###User-defined bridges
              <!-- User-defined bridge: User-defined bridge networks are superior to the default bridge network. -->
              - User-defined bridges provide better isolation and interoperability between containerized applications.
                - Containers connected to the same user-defined bridge network automatically expose all ports to each other, and no ports to the outside world.
              - User-defined bridges provide automatic DNS resolution between containers.
                - Containers can resolve each other by name or alias.
              - Containers can be attached and detached on the fly
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              Create a user-defined bridge network
              `$ docker network create my-net`
              Display create options
              `$ docker network create --help`

              ---
              Remove a user-defined bridge network
              `$ docker network rm my-net`
            </script>
          </section>
          <section data-markdown>
            <script type="text/template">
              Connect a container to a user-defined bridge
              `$ docker create --name my-nginx --network my-net --publish 8080:80 nginx:latest`

              ---
              connect a running container to an existing user-defined bridge
              `$ docker network connect my-net my-nginx`
              Disconnect a container from a user-defined bridge
              `$ docker network disconnect my-net my-nginx`

            </script>
          </section>
        </section>

        <section>

          <section data-markdown>
            <script type="text/template">
              #10. Docker in Continuous Integration
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Traditional Continuous Integration
              <img src="img/docker_traditional_continuous_integration.png" alt="">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Using Docker in CI. method 1
              - CI server builds Docker image and pushes into Docker Hub
              <img src="img/docker_in_CI.png" alt="">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Docker Hub Auto Build. Method 2
              - Docker Hub detects commits to source repository and builds the image
              - Container is run during image build
              - Testing done inside container
              <img src="img/docker_hub_auto_build.png" alt="">
            </script>
          </section>

        </section>

        <section>

          <section data-markdown>
            <script type="text/template">
              #11. Docker Compose
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              >Docker **Compose** is a tool for creating and managing multi container applications

              - Containers are all defined in a single file called "docker-compose.yml"
              - Each container runs a particular component/service of your application.
              <br>For example: Web front end / User authentification / Payments / Database
              - Container links are defined
              - Compose will spin up all your containers in a single command
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Configuring the Compose yml file
              - Defines the services that make up your application
              - Each service contains instructions for building and running a container
              ```
              version: '3'
              services:
                javaclient:
                  build: .
                  command: java HelloWorld
                  links:
                  - redis
                redis:
                  image: redis
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Build and image instruction
              - **Build** defines the path to the Dockerfile that will be used to build the image
              - Container will be run using the image built
              - **Image** defines the image that will be used to run the container
              - All service must have either a build or image instruction
              ```
              version: '3'
              services:
                javaclient:
                  build: . # Build image using Dockerfile in current directory
                redis:
                  image: redis # Use the latest redis image from DockerHub
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Links
              - Same concept as container linking
              - Specify `<service name>:<alias>`
              - If no alias is specified, the service name will be used as the alias
              - Creates an entry for the alias inside the container's /etc/hosts file
              ```
              version: '3'
              services:
                javaclient:
                  build: .
                  command: java HelloWorld
                  links: # <================
                  - redis
                redis:
                  image: redis
              ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Running your application
              - Use `docker-compose up`
              - Up command will
                - Build the image for each service
                - Create and start the containers
            </script>
          </section>
        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              #12. Building Micro Service Applications
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Traditional style monolithic architecture
              <img src="img/docker_architecture_traditional.png" alt="">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Micro service architecture
              <img src="img/docker_architecture_microservices.png" alt="">
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
              ##Advantages
              - Each service can be developed and upgraded independently
              - Easier for developers to understand
                - Only have to focus on their service
              - If one service goes down, the application should still run, albeit with reduced functions
              - Application is easier to troubleshoot
              - The whole application does not have to be committed to one technology stack
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
            </script>
          </section>

        </section>

        <section>
          <section data-markdown>
            <script type="text/template">
              ##Sources and reference:
              <br>
              https://docs.docker.com/userguide/
              https://training.docker.com/
              <br>
              By Johnny Tu
              <br>
              <br>
              https://docs.docker.com/reference/commandline/run/
            </script>
          </section>
        </section>

      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,
        slideNumber: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
        ]
        });

      </script>

  </body>
</html>
